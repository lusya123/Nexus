<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nexus — Agent Arena Monitor</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #0a0a0f;
  color: #e0e0e0;
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  overflow-x: hidden;
}

#header {
  padding: 16px 24px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid #1a1a2e;
  background: #0d0d14;
}

#header h1 {
  font-size: 16px;
  font-weight: 600;
  color: #8888aa;
  letter-spacing: 2px;
}

#status {
  font-size: 12px;
  color: #555;
}

#status.connected { color: #4ade80; }
#status.disconnected { color: #f87171; }

#grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
  gap: 16px;
  padding: 20px;
}

.card {
  background: #111118;
  border: 1px solid #1e1e30;
  border-radius: 10px;
  display: flex;
  flex-direction: column;
  max-height: 500px;
  overflow: hidden;
  transition: border-color 0.3s, box-shadow 0.3s;
}

.card-header {
  padding: 10px 14px;
  display: flex;
  align-items: center;
  gap: 8px;
  border-bottom: 1px solid #1a1a2e;
  flex-shrink: 0;
}

.tool-badge {
  font-size: 10px;
  font-weight: 700;
  padding: 2px 8px;
  border-radius: 4px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.tool-claude-code .tool-badge { background: #1e3a5f; color: #60a5fa; }
.tool-codex .tool-badge { background: #1a3d2e; color: #4ade80; }
.tool-openclaw .tool-badge { background: #2d1a4e; color: #a78bfa; }

.card-name {
  font-size: 13px;
  font-weight: 500;
  color: #ccc;
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.card-time {
  font-size: 11px;
  color: #555;
  flex-shrink: 0;
}

.card-body {
  flex: 1;
  overflow-y: auto;
  padding: 10px 14px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.card-body::-webkit-scrollbar { width: 4px; }
.card-body::-webkit-scrollbar-track { background: transparent; }
.card-body::-webkit-scrollbar-thumb { background: #2a2a3e; border-radius: 2px; }

.msg {
  font-size: 12px;
  line-height: 1.5;
  padding: 6px 10px;
  border-radius: 6px;
  max-height: 120px;
  overflow: hidden;
  word-break: break-word;
  white-space: pre-wrap;
}

.msg-user {
  background: #1a1a2e;
  color: #a0a0c0;
  border-left: 2px solid #3b82f6;
}

.msg-assistant {
  background: #0f0f1a;
  color: #d0d0e0;
  border-left: 2px solid #22c55e;
}

/* ─── State Styles ─── */
.card.state-active {
  border-color: #1e3a5f;
  animation: pulse 2s ease-in-out infinite;
}

.card.state-idle {
  border-color: #1a1a2e;
  opacity: 0.85;
}

.card.state-cooling {
  opacity: 0;
  transform: scale(0.97);
  pointer-events: none;
}

/* ─── Animations ─── */
@keyframes card-enter {
  0%   { opacity: 0; transform: translateY(20px) scale(0.95); }
  60%  { opacity: 1; transform: translateY(-4px) scale(1.01); }
  100% { opacity: 1; transform: translateY(0) scale(1); }
}

@keyframes pulse {
  0%, 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.08); }
  50%      { box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.12); }
}

.card-entering {
  animation: card-enter 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}

/* Tool-specific active colors */
.tool-claude-code.state-active { border-color: #2563eb33; }
.tool-codex.state-active { border-color: #16a34a33; }
.tool-openclaw.state-active { border-color: #7c3aed33; }

#empty-state {
  text-align: center;
  padding: 80px 20px;
  color: #444;
  font-size: 14px;
}

#empty-state .icon { font-size: 48px; margin-bottom: 16px; }
</style>
</head>
<body>

<div id="header">
  <h1>NEXUS</h1>
  <span id="status" class="disconnected">● disconnected</span>
</div>

<div id="grid"></div>

<div id="empty-state">
  <div class="icon">◉</div>
  <div>Waiting for active sessions...</div>
  <div style="margin-top:8px;font-size:12px;color:#333">
    Start a Claude Code, Codex, or OpenClaw session to see it here
  </div>
</div>

<script>
// ─── State ───
const sessionCards = new Map(); // sessionId → { el, messages }
const entryQueue = [];
const STAGGER_DELAY = 150;
let ws = null;
let reconnectTimer = null;

// ─── Entry Queue (staggered entrance) ───
setInterval(() => {
  if (entryQueue.length > 0) {
    const { sessionId, el } = entryQueue.shift();
    const grid = document.getElementById('grid');
    grid.prepend(el);
    el.classList.add('card-entering');
    el.addEventListener('animationend', () => el.classList.remove('card-entering'), { once: true });
    updateEmptyState();
  }
}, STAGGER_DELAY);

// ─── Card Creation ───
function createCard(sessionId, tool, name, state, messages) {
  const el = document.createElement('div');
  el.className = `card tool-${tool} state-${state}`;
  el.dataset.sessionId = sessionId;
  el.dataset.lastActivity = Date.now();

  const toolLabel = {
    'claude-code': 'Claude Code',
    'codex': 'Codex',
    'openclaw': 'OpenClaw'
  }[tool] || tool;

  el.innerHTML = `
    <div class="card-header">
      <span class="tool-badge">${toolLabel}</span>
      <span class="card-name" title="${name}">${name}</span>
      <span class="card-time">just now</span>
    </div>
    <div class="card-body"></div>
  `;

  const body = el.querySelector('.card-body');
  for (const msg of messages) {
    appendMessage(body, msg);
  }
  scrollToBottom(body);

  sessionCards.set(sessionId, { el, body });
  entryQueue.push({ sessionId, el });
}

function appendMessage(body, msg) {
  const div = document.createElement('div');
  div.className = `msg msg-${msg.role}`;
  div.textContent = msg.content;
  body.appendChild(div);
}

function scrollToBottom(body) {
  requestAnimationFrame(() => {
    body.scrollTop = body.scrollHeight;
  });
}

function updateEmptyState() {
  const empty = document.getElementById('empty-state');
  const grid = document.getElementById('grid');
  empty.style.display = grid.children.length === 0 ? 'block' : 'none';
}

function updateCardTime(sessionId) {
  const card = sessionCards.get(sessionId);
  if (!card) return;
  card.el.dataset.lastActivity = Date.now();
  const timeEl = card.el.querySelector('.card-time');
  if (timeEl) timeEl.textContent = 'just now';
}

// ─── Time updater ───
setInterval(() => {
  for (const [id, card] of sessionCards) {
    const timeEl = card.el.querySelector('.card-time');
    if (!timeEl) continue;
    const elapsed = Date.now() - parseInt(card.el.dataset.lastActivity || '0');
    if (elapsed < 5000) timeEl.textContent = 'just now';
    else if (elapsed < 60000) timeEl.textContent = `${Math.floor(elapsed / 1000)}s ago`;
    else if (elapsed < 3600000) timeEl.textContent = `${Math.floor(elapsed / 60000)}m ago`;
    else timeEl.textContent = `${Math.floor(elapsed / 3600000)}h ago`;
  }
}, 5000);


// ─── WebSocket ───
function connect() {
  const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
  ws = new WebSocket(`${protocol}//${location.host}`);

  ws.onopen = () => {
    document.getElementById('status').className = 'connected';
    document.getElementById('status').textContent = '● connected';
    if (reconnectTimer) { clearInterval(reconnectTimer); reconnectTimer = null; }
  };

  ws.onclose = () => {
    document.getElementById('status').className = 'disconnected';
    document.getElementById('status').textContent = '● disconnected';
    if (!reconnectTimer) {
      reconnectTimer = setInterval(connect, 3000);
    }
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    handleMessage(data);
  };
}

function handleMessage(data) {
  switch (data.type) {
    case 'session_init': {
      if (sessionCards.has(data.sessionId)) return;
      createCard(data.sessionId, data.tool, data.name, data.state || 'active', data.messages || []);
      break;
    }
    case 'message_add': {
      const card = sessionCards.get(data.sessionId);
      if (!card) return;
      appendMessage(card.body, data.message);
      scrollToBottom(card.body);
      updateCardTime(data.sessionId);
      break;
    }
    case 'state_change': {
      const card = sessionCards.get(data.sessionId);
      if (!card) return;
      // Remove old state classes
      card.el.classList.remove('state-active', 'state-idle', 'state-cooling');
      card.el.classList.add(`state-${data.state}`);
      if (data.state === 'cooling' && data.cooldownMs) {
        card.el.style.transition = `opacity ${data.cooldownMs}ms ease-out, transform ${data.cooldownMs}ms ease-out`;
      }
      break;
    }
    case 'session_remove': {
      const card = sessionCards.get(data.sessionId);
      if (!card) {
        sessionCards.delete(data.sessionId);
        return;
      }
      card.el.addEventListener('transitionend', () => {
        card.el.remove();
        sessionCards.delete(data.sessionId);
        updateEmptyState();
      }, { once: true });
      // If not already cooling, force remove after a short delay
      if (!card.el.classList.contains('state-cooling')) {
        card.el.classList.add('state-cooling');
        card.el.style.transition = 'opacity 0.8s ease-out, transform 0.8s ease-out';
      }
      // Fallback removal
      setTimeout(() => {
        if (sessionCards.has(data.sessionId)) {
          card.el.remove();
          sessionCards.delete(data.sessionId);
          updateEmptyState();
        }
      }, 5000);
      break;
    }
  }
}

// ─── Init ───
connect();
updateEmptyState();
</script>
</body>
</html>
